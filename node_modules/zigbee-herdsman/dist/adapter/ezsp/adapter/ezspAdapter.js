"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const debug_1 = __importDefault(require("debug"));
const adapter_1 = __importDefault(require("../../adapter"));
const debug = debug_1.default("zigbee-herdsman:adapter:ezsp");
const driver_1 = require("../driver");
const types_1 = require("../driver/types");
const zcl_1 = require("../../../zcl");
const Events = __importStar(require("../../events"));
const utils_1 = require("../../../utils");
class EZSPAdapter extends adapter_1.default {
    constructor(networkOptions, serialPortOptions, backupPath, adapterOptions) {
        super(networkOptions, serialPortOptions, backupPath, adapterOptions);
        this.port = serialPortOptions;
        this.waitress = new utils_1.Waitress(this.waitressValidator, this.waitressTimeoutFormatter);
        this.driver = new driver_1.Driver();
        this.driver.on('deviceJoined', this.handleDeviceJoin.bind(this));
        this.driver.on('deviceLeft', this.handleDeviceLeft.bind(this));
        this.driver.on('incomingMessage', this.processMessage.bind(this));
    }
    processMessage(frame) {
        return __awaiter(this, void 0, void 0, function* () {
            // todo
            debug(`processMessage: ${JSON.stringify(frame)}`);
            if (!frame.senderEui64) {
                frame.senderEui64 = yield this.driver.networkIdToEUI64(frame.sender);
            }
            if (frame.apsFrame.profileId == 0) {
                if (frame.apsFrame.clusterId == types_1.EmberZDOCmd.Device_annce &&
                    frame.apsFrame.destinationEndpoint == 0) {
                    let nwk, rst, ieee;
                    [nwk, rst] = types_1.uint16_t.deserialize(types_1.uint16_t, frame.message.slice(1));
                    [ieee, rst] = types_1.EmberEUI64.deserialize(types_1.EmberEUI64, rst);
                    ieee = new types_1.EmberEUI64(ieee);
                    debug("ZDO Device announce: %s, %s", nwk, ieee.toString());
                    this.handleDeviceJoin([nwk, ieee]);
                }
            }
            else if (frame.apsFrame.profileId == 260) {
                try {
                    const payload = {
                        frame: zcl_1.ZclFrame.fromBuffer(frame.apsFrame.clusterId, frame.message),
                        address: frame.sender,
                        endpoint: frame.apsFrame.sourceEndpoint,
                        linkquality: frame.lqi,
                        groupID: frame.apsFrame.groupId,
                    };
                    this.waitress.resolve(payload);
                    this.emit(Events.Events.zclData, payload);
                }
                catch (error) {
                    const payload = {
                        clusterID: frame.apsFrame.clusterId,
                        data: frame.message,
                        address: frame.sender,
                        endpoint: frame.apsFrame.sourceEndpoint,
                        linkquality: frame.lqi,
                        groupID: frame.apsFrame.groupId,
                    };
                    this.emit(Events.Events.rawData, payload);
                }
            }
            this.emit('event', frame);
        });
    }
    handleDeviceJoin(arr) {
        return __awaiter(this, void 0, void 0, function* () {
            // todo
            let [nwk, ieee] = arr;
            debug('Device join request received: %s %s', nwk, ieee.toString('hex'));
            const payload = {
                networkAddress: nwk,
                ieeeAddr: `0x${ieee.toString('hex')}`,
            };
            if (nwk == 0) {
                const nd = yield this.nodeDescriptor(nwk);
            }
            else {
                this.emit(Events.Events.deviceJoined, payload);
            }
        });
    }
    handleDeviceLeft(arr) {
        // todo
        let [nwk, ieee] = arr;
        debug('Device left network request received: %s %s', nwk, ieee);
        const payload = {
            networkAddress: nwk,
            ieeeAddr: `0x${ieee.toString('hex')}`,
        };
        this.emit(Events.Events.deviceLeave, payload);
    }
    /**
     * Adapter methods
     */
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.driver.startup(this.port.path, {
                baudRate: this.port.baudRate || 115200,
                parity: 'none',
                stopBits: 1,
                xon: true,
                xoff: true
            }, this.networkOptions);
            return Promise.resolve("resumed");
        });
    }
    stop() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.driver.stop();
        });
    }
    static isValidPath(path) {
        return __awaiter(this, void 0, void 0, function* () {
            // todo
            return false;
        });
    }
    static autoDetectPath() {
        return __awaiter(this, void 0, void 0, function* () {
            // todo
            return '';
        });
    }
    getCoordinator() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.driver.queue.execute(() => __awaiter(this, void 0, void 0, function* () {
                const networkAddress = 0x0000;
                const message = yield this.driver.zdoRequest(networkAddress, types_1.EmberZDOCmd.Active_EP_req, types_1.EmberZDOCmd.Active_EP_rsp, networkAddress);
                const activeEndpoints = [...message[3]];
                const endpoints = [];
                for (const endpoint of activeEndpoints) {
                    const descriptor = yield this.driver.zdoRequest(networkAddress, types_1.EmberZDOCmd.Simple_Desc_req, types_1.EmberZDOCmd.Simple_Desc_rsp, networkAddress, endpoint);
                    endpoints.push({
                        profileID: descriptor[4].profileid,
                        ID: descriptor[4].endpoint,
                        deviceID: descriptor[4].deviceid,
                        inputClusters: descriptor[4].inclusterlist,
                        outputClusters: descriptor[4].outclusterlist,
                    });
                }
                return {
                    networkAddress: networkAddress,
                    manufacturerID: 0,
                    ieeeAddr: `0x${this.driver.ieee.toString()}`,
                    endpoints,
                };
            }));
        });
    }
    permitJoin(seconds, networkAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            // todo
            yield this.driver.permitJoining(seconds);
            return Promise.resolve();
        });
    }
    getCoordinatorVersion() {
        return __awaiter(this, void 0, void 0, function* () {
            // todo
            return { type: 'EmberZNet', meta: this.driver.version };
        });
    }
    reset(type) {
        return __awaiter(this, void 0, void 0, function* () {
            return Promise.reject();
        });
    }
    supportsLED() {
        return __awaiter(this, void 0, void 0, function* () {
            return false;
        });
    }
    setLED(enabled) {
        return __awaiter(this, void 0, void 0, function* () {
            return Promise.reject();
        });
    }
    lqi(networkAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.driver.queue.execute(() => __awaiter(this, void 0, void 0, function* () {
                const neighbors = [];
                const request = (startIndex) => __awaiter(this, void 0, void 0, function* () {
                    const result = yield this.driver.zdoRequest(networkAddress, types_1.EmberZDOCmd.Mgmt_Lqi_req, types_1.EmberZDOCmd.Mgmt_Lqi_rsp, startIndex);
                    if (result[1] !== types_1.EmberStatus.SUCCESS) {
                        throw new Error(`LQI for '${networkAddress}' failed`);
                    }
                    return result;
                });
                // eslint-disable-next-line
                const add = (list) => {
                    for (const entry of list) {
                        neighbors.push({
                            linkquality: entry.lqi,
                            networkAddress: entry.nodeid,
                            ieeeAddr: `0x${new types_1.EmberEUI64(entry.ieee).toString()}`,
                            relationship: (entry.packed >> 4) & 0x7,
                            depth: entry.depth,
                        });
                    }
                };
                let response = yield request(0);
                add(response[2].neighbors);
                const size = response[2].entries;
                let nextStartIndex = response[2].neighbors.length;
                while (neighbors.length < size) {
                    response = yield request(nextStartIndex);
                    add(response[2].neighbors);
                    nextStartIndex += response[2].neighbors.length;
                }
                return { neighbors };
            }), networkAddress);
        });
    }
    routingTable(networkAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            // todo
            return Promise.reject();
        });
    }
    nodeDescriptor(networkAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                debug(`Requesting 'Node Descriptor' for '${networkAddress}'`);
                const result = yield this.nodeDescriptorInternal(networkAddress);
                return result;
            }
            catch (error) {
                debug(`Node descriptor request for '${networkAddress}' failed (${error}), retry`);
                throw error;
            }
        });
    }
    nodeDescriptorInternal(networkAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.driver.queue.execute(() => __awaiter(this, void 0, void 0, function* () {
                const descriptor = yield this.driver.zdoRequest(networkAddress, types_1.EmberZDOCmd.Node_Desc_req, types_1.EmberZDOCmd.Node_Desc_rsp, networkAddress);
                return {
                    manufacturerCode: descriptor[2].manufacturer_code,
                    type: (descriptor[1] == 0) ? 'Coordinator' : 'EndDevice'
                };
            }));
        });
    }
    activeEndpoints(networkAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            debug(`Requesting 'Active endpoints' for '${networkAddress}'`);
            return this.driver.queue.execute(() => __awaiter(this, void 0, void 0, function* () {
                const endpoints = yield this.driver.zdoRequest(networkAddress, types_1.EmberZDOCmd.Active_EP_req, types_1.EmberZDOCmd.Active_EP_rsp, networkAddress);
                return { endpoints: [...endpoints[3]] };
            }), networkAddress);
        });
    }
    simpleDescriptor(networkAddress, endpointID) {
        return __awaiter(this, void 0, void 0, function* () {
            // todo
            debug(`Requesting 'Simple Descriptor' for '${networkAddress}' endpoint ${endpointID}`);
            return this.driver.queue.execute(() => __awaiter(this, void 0, void 0, function* () {
                const descriptor = yield this.driver.zdoRequest(networkAddress, types_1.EmberZDOCmd.Simple_Desc_req, types_1.EmberZDOCmd.Simple_Desc_rsp, networkAddress, endpointID);
                return {
                    profileID: descriptor[4].profileid,
                    endpointID: descriptor[4].endpoint,
                    deviceID: descriptor[4].deviceid,
                    inputClusters: descriptor[4].inclusterlist,
                    outputClusters: descriptor[4].outclusterlist,
                };
            }), networkAddress);
        });
    }
    sendZclFrameToEndpoint(ieeeAddr, networkAddress, endpoint, zclFrame, timeout, disableResponse, disableRecovery, sourceEndpoint) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.driver.queue.execute(() => __awaiter(this, void 0, void 0, function* () {
                return this.sendZclFrameToEndpointInternal(ieeeAddr, networkAddress, endpoint, sourceEndpoint || 1, zclFrame, timeout, disableResponse, disableRecovery, 0, 0, false, false, false, null);
            }), networkAddress);
        });
    }
    sendZclFrameToEndpointInternal(ieeeAddr, networkAddress, endpoint, sourceEndpoint, zclFrame, timeout, disableResponse, disableRecovery, responseAttempt, dataRequestAttempt, checkedNetworkAddress, discoveredRoute, assocRemove, assocRestore) {
        return __awaiter(this, void 0, void 0, function* () {
            debug('sendZclFrameToEndpointInternal %s:%i/%i (%i,%i,%i)', ieeeAddr, networkAddress, endpoint, responseAttempt, dataRequestAttempt, this.driver.queue.count());
            let response = null;
            const command = zclFrame.getCommand();
            if (command.hasOwnProperty('response') && disableResponse === false) {
                response = this.waitForInternal(networkAddress, endpoint, zclFrame.Header.transactionSequenceNumber, zclFrame.Cluster.ID, command.response, timeout);
            }
            else if (!zclFrame.Header.frameControl.disableDefaultResponse) {
                response = this.waitForInternal(networkAddress, endpoint, zclFrame.Header.transactionSequenceNumber, zclFrame.Cluster.ID, zcl_1.Foundation.defaultRsp.ID, timeout);
            }
            const frame = this.driver.makeApsFrame(zclFrame.Cluster.ID);
            frame.profileId = 0x0104;
            frame.sourceEndpoint = sourceEndpoint || 0x01;
            frame.destinationEndpoint = endpoint;
            frame.groupId = 0;
            frame.options = types_1.EmberApsOption.APS_OPTION_ENABLE_ROUTE_DISCOVERY | types_1.EmberApsOption.APS_OPTION_RETRY;
            const dataConfirmResult = yield this.driver.request(networkAddress, frame, zclFrame.toBuffer());
            if (response !== null) {
                try {
                    const result = yield response.start().promise;
                    return result;
                }
                catch (error) {
                    debug('Response timeout (%s:%d,%d)', ieeeAddr, networkAddress, responseAttempt);
                    if (responseAttempt < 1 && !disableRecovery) {
                        return this.sendZclFrameToEndpointInternal(ieeeAddr, networkAddress, endpoint, sourceEndpoint, zclFrame, timeout, disableResponse, disableRecovery, responseAttempt + 1, dataRequestAttempt, checkedNetworkAddress, discoveredRoute, assocRemove, assocRestore);
                    }
                    else {
                        throw error;
                    }
                }
            }
            else {
                return null;
            }
        });
    }
    sendZclFrameToGroup(groupID, zclFrame) {
        return __awaiter(this, void 0, void 0, function* () {
            // todo
            return Promise.reject();
        });
    }
    sendZclFrameToAll(endpoint, zclFrame, sourceEndpoint) {
        return __awaiter(this, void 0, void 0, function* () {
            // todo
            return Promise.resolve();
        });
    }
    bind(destinationNetworkAddress, sourceIeeeAddress, sourceEndpoint, clusterID, destinationAddressOrGroup, type, destinationEndpoint) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.driver.queue.execute(() => __awaiter(this, void 0, void 0, function* () {
                const ieee = new types_1.EmberEUI64(sourceIeeeAddress);
                const ieeeDst = new types_1.EmberEUI64(destinationAddressOrGroup);
                yield this.driver.zdoRequest(destinationNetworkAddress, types_1.EmberZDOCmd.Bind_req, types_1.EmberZDOCmd.Bind_rsp, ieee, sourceEndpoint, clusterID, { addrmode: 0x03, ieee: ieeeDst, endpoint: destinationEndpoint });
            }), destinationNetworkAddress);
        });
    }
    unbind(destinationNetworkAddress, sourceIeeeAddress, sourceEndpoint, clusterID, destinationAddressOrGroup, type, destinationEndpoint) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.driver.queue.execute(() => __awaiter(this, void 0, void 0, function* () {
                const ieee = new types_1.EmberEUI64(sourceIeeeAddress);
                const ieeeDst = new types_1.EmberEUI64(destinationAddressOrGroup);
                yield this.driver.zdoRequest(destinationNetworkAddress, types_1.EmberZDOCmd.Unbind_req, types_1.EmberZDOCmd.Unbind_rsp, ieee, sourceEndpoint, clusterID, { addrmode: 0x03, ieee: ieeeDst, endpoint: destinationEndpoint });
            }), destinationNetworkAddress);
        });
    }
    removeDevice(networkAddress, ieeeAddr) {
        return this.driver.queue.execute(() => __awaiter(this, void 0, void 0, function* () {
            const ieee = new types_1.EmberEUI64(ieeeAddr);
            yield this.driver.zdoRequest(networkAddress, types_1.EmberZDOCmd.Mgmt_Leave_req, types_1.EmberZDOCmd.Mgmt_Leave_rsp, ieee, 0x00);
        }), networkAddress);
    }
    getNetworkParameters() {
        return __awaiter(this, void 0, void 0, function* () {
            return {
                panID: this.driver.networkParams.panId,
                extendedPanID: this.driver.networkParams.extendedPanId[0],
                channel: this.driver.networkParams.radioChannel
            };
        });
    }
    supportsBackup() {
        return __awaiter(this, void 0, void 0, function* () {
            //todo
            return false;
        });
    }
    backup() {
        return __awaiter(this, void 0, void 0, function* () {
            // todo
            return Promise.reject();
        });
    }
    restoreChannelInterPAN() {
        return __awaiter(this, void 0, void 0, function* () {
            // todo
            throw new Error("not supported");
        });
    }
    sendZclFrameInterPANToIeeeAddr(zclFrame, ieeeAddr) {
        return __awaiter(this, void 0, void 0, function* () {
            // todo
            throw new Error("not supported");
        });
    }
    sendZclFrameInterPANBroadcast(zclFrame, timeout) {
        return __awaiter(this, void 0, void 0, function* () {
            // todo
            throw new Error("not supported");
        });
    }
    sendZclFrameInterPANBroadcastWithResponse(zclFrame, timeout) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error("not supported");
        });
    }
    sendZclFrameInterPANIeeeAddr(zclFrame, ieeeAddr) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error("not supported");
        });
    }
    setTransmitPower(value) {
        return __awaiter(this, void 0, void 0, function* () {
            // todo
        });
    }
    setChannelInterPAN(channel) {
        return __awaiter(this, void 0, void 0, function* () {
            //todo
        });
    }
    waitForInternal(networkAddress, endpoint, transactionSequenceNumber, clusterID, commandIdentifier, timeout) {
        const payload = {
            address: networkAddress, endpoint, clusterID, commandIdentifier,
            transactionSequenceNumber,
        };
        const waiter = this.waitress.waitFor(payload, timeout);
        const cancel = () => this.waitress.remove(waiter.ID);
        return { start: waiter.start, cancel };
    }
    waitFor(networkAddress, endpoint, frameType, direction, transactionSequenceNumber, clusterID, commandIdentifier, timeout) {
        const waiter = this.waitForInternal(networkAddress, endpoint, transactionSequenceNumber, clusterID, commandIdentifier, timeout);
        return { cancel: waiter.cancel, promise: waiter.start().promise };
    }
    waitressTimeoutFormatter(matcher, timeout) {
        return `Timeout - ${matcher.address} - ${matcher.endpoint}` +
            ` - ${matcher.transactionSequenceNumber} - ${matcher.clusterID}` +
            ` - ${matcher.commandIdentifier} after ${timeout}ms`;
    }
    waitressValidator(payload, matcher) {
        const transactionSequenceNumber = payload.frame.Header.transactionSequenceNumber;
        return (!matcher.address || payload.address === matcher.address) &&
            payload.endpoint === matcher.endpoint &&
            (!matcher.transactionSequenceNumber || transactionSequenceNumber === matcher.transactionSequenceNumber) &&
            payload.frame.Cluster.ID === matcher.clusterID &&
            matcher.commandIdentifier === payload.frame.Header.commandIdentifier;
    }
}
exports.default = EZSPAdapter;
//# sourceMappingURL=ezspAdapter.js.map