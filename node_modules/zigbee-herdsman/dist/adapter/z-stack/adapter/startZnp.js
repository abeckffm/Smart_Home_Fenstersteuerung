"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const unpi_1 = require("../unpi");
const Constants = __importStar(require("../constants"));
const es6_1 = __importDefault(require("fast-deep-equal/es6"));
const Zcl = __importStar(require("../../../zcl"));
const tstype_1 = require("./tstype");
const debug_1 = __importDefault(require("debug"));
const backup_1 = require("./backup");
const nvItems_1 = __importDefault(require("./nvItems"));
const fs_1 = __importDefault(require("fs"));
const debug = debug_1.default('zigbee-herdsman:adapter:zStack:startZnp');
const Subsystem = unpi_1.Constants.Subsystem;
const { DevStates, ZnpCommandStatus } = Constants.COMMON;
const EndpointDefaults = {
    appdeviceid: 0x0005,
    appdevver: 0,
    appnuminclusters: 0,
    appinclusterlist: [],
    appnumoutclusters: 0,
    appoutclusterlist: [],
    latencyreq: Constants.AF.networkLatencyReq.NO_LATENCY_REQS,
};
const Endpoints = [
    Object.assign(Object.assign({}, EndpointDefaults), { endpoint: 1, appprofid: 0x0104 }),
    Object.assign(Object.assign({}, EndpointDefaults), { endpoint: 2, appprofid: 0x0101 }),
    Object.assign(Object.assign({}, EndpointDefaults), { endpoint: 3, appprofid: 0x0105 }),
    Object.assign(Object.assign({}, EndpointDefaults), { endpoint: 4, appprofid: 0x0107 }),
    Object.assign(Object.assign({}, EndpointDefaults), { endpoint: 5, appprofid: 0x0108 }),
    Object.assign(Object.assign({}, EndpointDefaults), { endpoint: 6, appprofid: 0x0109 }),
    Object.assign(Object.assign({}, EndpointDefaults), { endpoint: 8, appprofid: 0x0104 }),
    Object.assign(Object.assign({}, EndpointDefaults), { endpoint: 10, appprofid: 0x0104 }),
    Object.assign(Object.assign({}, EndpointDefaults), { endpoint: 11, appprofid: 0x0104, appdeviceid: 0x0400, appnumoutclusters: 2, appoutclusterlist: [Zcl.Utils.getCluster('ssIasZone').ID, Zcl.Utils.getCluster('ssIasWd').ID], appnuminclusters: 1, appinclusterlist: [Zcl.Utils.getCluster('ssIasAce').ID] }),
    Object.assign(Object.assign({}, EndpointDefaults), { endpoint: 0x6E, appprofid: 0x0104 }),
    Object.assign(Object.assign({}, EndpointDefaults), { endpoint: 12, appprofid: 0xc05e }),
    Object.assign(Object.assign({}, EndpointDefaults), { endpoint: 13, appprofid: 0x0104, appnuminclusters: 1, appinclusterlist: [Zcl.Utils.getCluster('genOta').ID] }),
    Object.assign(Object.assign({}, EndpointDefaults), { endpoint: 47, appprofid: 0x0104 }),
    Object.assign(Object.assign({}, EndpointDefaults), { endpoint: 242, appprofid: 0xa1e0 }),
];
function validateItem(znp, item, message, subsystem = Subsystem.SYS, command = 'osalNvRead', expectedStatuses = [ZnpCommandStatus.SUCCESS]) {
    return __awaiter(this, void 0, void 0, function* () {
        const result = yield znp.request(subsystem, command, item, null, expectedStatuses);
        if (!es6_1.default(result.payload.value, item.value)) {
            debug(`Item '${message}' is invalid, got '${JSON.stringify(result.payload.value)}', ` +
                `expected '${JSON.stringify(item.value)}'`);
            return false;
        }
        else {
            debug(`Item '${message}' is valid`);
            return true;
        }
    });
}
function needsToBeInitialised(znp, version, options) {
    return __awaiter(this, void 0, void 0, function* () {
        let valid = true;
        valid = valid && (yield validateItem(znp, nvItems_1.default.znpHasConfigured(version), 'hasConfigured', Subsystem.SYS, 'osalNvRead', [ZnpCommandStatus.SUCCESS, ZnpCommandStatus.INVALID_PARAM]));
        valid = valid && (yield validateItem(znp, nvItems_1.default.channelList(options.channelList), 'channelList'));
        valid = valid && (yield validateItem(znp, nvItems_1.default.networkKeyDistribute(options.networkKeyDistribute), 'networkKeyDistribute'));
        if (version === tstype_1.ZnpVersion.zStack3x0) {
            valid = valid && (yield validateItem(znp, nvItems_1.default.networkKey(options.networkKey), 'networkKey'));
        }
        else {
            valid = valid && (yield validateItem(znp, nvItems_1.default.networkKey(options.networkKey), 'networkKey', Subsystem.SAPI, 'readConfiguration'));
        }
        if (valid) {
            valid = valid && (yield validateItem(znp, nvItems_1.default.panID(options.panID), 'panID'));
            valid = valid && (yield validateItem(znp, nvItems_1.default.extendedPanID(options.extendedPanID), 'extendedPanID'));
            if (!valid) {
                if (version === tstype_1.ZnpVersion.zStack30x || version === tstype_1.ZnpVersion.zStack3x0) {
                    // Zigbee-herdsman =< 0.6.5 didn't set the panID and extendedPanID on zStack 3.
                    // As we are now checking it, it would trigger a reinitialise which will cause users
                    // to lose their network. Therefore we are ignoring this case.
                    // When the panID has never been set, it will be [0xFF, 0xFF].
                    const current = yield znp.request(Subsystem.SYS, 'osalNvRead', nvItems_1.default.panID(options.panID));
                    if (Buffer.compare(current.payload.value, Buffer.from([0xFF, 0XFF])) === 0) {
                        debug('Skip enforcing panID because a random panID is used');
                        valid = true;
                    }
                }
            }
        }
        return !valid;
    });
}
function boot(znp) {
    return __awaiter(this, void 0, void 0, function* () {
        const result = yield znp.request(Subsystem.UTIL, 'getDeviceInfo', {});
        if (result.payload.devicestate !== DevStates.ZB_COORD) {
            debug('Start ZNP as coordinator...');
            const started = znp.waitFor(unpi_1.Constants.Type.AREQ, Subsystem.ZDO, 'stateChangeInd', { state: 9 }, 60000);
            znp.request(Subsystem.ZDO, 'startupFromApp', { startdelay: 100 }, null, [ZnpCommandStatus.SUCCESS, ZnpCommandStatus.FAILURE]);
            yield started.start().promise;
            debug('ZNP started as coordinator');
        }
        else {
            debug('ZNP is already started as coordinator');
        }
    });
}
function registerEndpoints(znp) {
    return __awaiter(this, void 0, void 0, function* () {
        const activeEpResponse = znp.waitFor(unpi_1.Constants.Type.AREQ, Subsystem.ZDO, 'activeEpRsp');
        znp.request(Subsystem.ZDO, 'activeEpReq', { dstaddr: 0, nwkaddrofinterest: 0 });
        const activeEp = yield activeEpResponse.start().promise;
        for (const endpoint of Endpoints) {
            if (activeEp.payload.activeeplist.includes(endpoint.endpoint)) {
                debug(`Endpoint '${endpoint.endpoint}' already registered`);
            }
            else {
                debug(`Registering endpoint '${endpoint.endpoint}'`);
                yield znp.request(Subsystem.AF, 'register', endpoint);
            }
        }
    });
}
function initialise(znp, version, options) {
    return __awaiter(this, void 0, void 0, function* () {
        debug('Initialising coordinator');
        yield znp.request(Subsystem.SYS, 'resetReq', { type: Constants.SYS.resetType.SOFT });
        yield znp.request(Subsystem.SYS, 'osalNvWrite', nvItems_1.default.startupOption(0x02));
        yield znp.request(Subsystem.SYS, 'resetReq', { type: Constants.SYS.resetType.SOFT });
        yield znp.request(Subsystem.SYS, 'osalNvWrite', nvItems_1.default.logicalType(Constants.ZDO.deviceLogicalType.COORDINATOR));
        yield znp.request(Subsystem.SYS, 'osalNvWrite', nvItems_1.default.networkKeyDistribute(options.networkKeyDistribute));
        yield znp.request(Subsystem.SYS, 'osalNvWrite', nvItems_1.default.zdoDirectCb());
        yield znp.request(Subsystem.SYS, 'osalNvWrite', nvItems_1.default.channelList(options.channelList));
        yield znp.request(Subsystem.SYS, 'osalNvWrite', nvItems_1.default.panID(options.panID));
        yield znp.request(Subsystem.SYS, 'osalNvWrite', nvItems_1.default.extendedPanID(options.extendedPanID));
        if (version === tstype_1.ZnpVersion.zStack30x || version === tstype_1.ZnpVersion.zStack3x0) {
            yield znp.request(Subsystem.SYS, 'osalNvWrite', nvItems_1.default.networkKey(options.networkKey));
            // Default link key is already OK for Z-Stack 3 ('ZigBeeAlliance09')
            const channelMask = Buffer.from(Constants.Utils.getChannelMask(options.channelList)).readUInt32LE(0);
            yield znp.request(Subsystem.APP_CNF, 'bdbSetChannel', { isPrimary: 0x1, channel: channelMask });
            yield znp.request(Subsystem.APP_CNF, 'bdbSetChannel', { isPrimary: 0x0, channel: 0x0 });
            const started = znp.waitFor(unpi_1.Constants.Type.AREQ, Subsystem.ZDO, 'stateChangeInd', { state: 9 }, 60000);
            yield znp.request(Subsystem.APP_CNF, 'bdbStartCommissioning', { mode: 0x04 });
            try {
                yield started.start().promise;
            }
            catch (error) {
                throw new Error('Coordinator failed to start, probably the panID is already in use, try a different panID or channel');
            }
            yield znp.request(Subsystem.APP_CNF, 'bdbStartCommissioning', { mode: 0x02 });
        }
        else {
            yield znp.request(Subsystem.SAPI, 'writeConfiguration', nvItems_1.default.networkKey(options.networkKey));
            yield znp.request(Subsystem.SYS, 'osalNvWrite', nvItems_1.default.tcLinkKey12());
        }
        // expect status code NV_ITEM_UNINIT (= item created and initialized)
        yield znp.request(Subsystem.SYS, 'osalNvItemInit', nvItems_1.default.znpHasConfiguredInit(version), null, [ZnpCommandStatus.SUCCESS, ZnpCommandStatus.NV_ITEM_INITIALIZED]);
        yield znp.request(Subsystem.SYS, 'osalNvWrite', nvItems_1.default.znpHasConfigured(version));
    });
}
function addToGroup(znp, endpoint, group) {
    return __awaiter(this, void 0, void 0, function* () {
        const result = yield znp.request(5, 'extFindGroup', { endpoint, groupid: group }, null, [ZnpCommandStatus.SUCCESS, ZnpCommandStatus.FAILURE]);
        if (result.payload.status === ZnpCommandStatus.FAILURE) {
            yield znp.request(5, 'extAddGroup', { endpoint, groupid: group, namelen: 0, groupname: [] });
        }
    });
}
exports.default = (znp, version, options, greenPowerGroup, backupPath) => __awaiter(void 0, void 0, void 0, function* () {
    let result = 'resumed';
    const hasConfigured = yield validateItem(znp, nvItems_1.default.znpHasConfigured(version), 'hasConfigured', Subsystem.SYS, 'osalNvRead', [ZnpCommandStatus.SUCCESS, ZnpCommandStatus.INVALID_PARAM]);
    // Restore from backup when the coordinator has never been configured yet.
    if (backupPath && fs_1.default.existsSync(backupPath) && !hasConfigured) {
        debug('Restoring coordinator from backup');
        yield backup_1.Restore(znp, backupPath, options);
        result = 'restored';
    }
    else if (yield needsToBeInitialised(znp, version, options)) {
        yield initialise(znp, version, options);
        if (version === tstype_1.ZnpVersion.zStack12) {
            // zStack12 allows to restore a network without restoring a backup (as long as the
            // networkey, panid and channel don't change).
            // If the device has not been configured yet we assume that this is the case.
            // If we always return 'reset' the controller clears the database on a reflash of the stick.
            result = hasConfigured ? 'reset' : 'restored';
        }
        else {
            result = 'reset';
        }
    }
    yield boot(znp);
    yield registerEndpoints(znp);
    // Add to required group to receive greenPower messages.
    yield addToGroup(znp, 242, greenPowerGroup);
    if (result === 'restored') {
        // Write channellist again, otherwise it doesnt seem to stick.
        yield znp.request(Subsystem.SYS, 'osalNvWrite', nvItems_1.default.channelList(options.channelList));
    }
    return result;
});
//# sourceMappingURL=startZnp.js.map